//***************************************************************************
@script:glsl:VSGBuffer
//***************************************************************************
#version 330

in vec4 vertPos;
in vec3 vertNorm;

#ifdef USE_DIFFUSE_SAMPLER
	in vec2 vertDiffuseUV;
#endif

uniform per_object_transforms {
	mat4 matMvp;
	mat4 matMv; // assumed orthogonal
};

smooth out vec4 varyingNormal;
#ifdef USE_DIFFUSE_SAMPLER
	smooth out vec2 varyingUV;
#endif

void main(void)
{
	varyingNormal = matMv * vec4(vertNorm, 0.0);	
#ifdef USE_DIFFUSE_SAMPLER
	varyingUV = vertDiffuseUV;
#endif
	gl_Position = matMvp * vertPos;
}

//***************************************************************************
@script:glsl:PSGBuffer
//***************************************************************************
#version 330

smooth in vec4 varyingNormal;
layout(location = 0) out vec4 albedoAndGlossMap;
layout(location = 1) out vec4 normalMap;

uniform per_material_properties {
	vec4 diffuseAndGloss;
};

#ifdef USE_DIFFUSE_SAMPLER
	sampler2D diffuseMap;
	smooth in vec2 varyingUV;
#endif

vec3 getDiffuseColor() {
#ifdef USE_DIFFUSE_SAMPLER
	return (texture(diffuseMap, varyingUV).rgb * diffuseAndGloss.rgb);
#else
	return diffuseAndGloss.rgb;
#endif
}

float getGloss() {
	return diffuseAndGloss.a;
}

vec2 getEncodedNormal(vec3 n) {
	vec2 enc = normalize(n.xy) * (sqrt(n.z*0.5+0.5));
    enc = enc*0.5+0.5;
    return enc;
}

vec2 getNormal() {
	return getEncodedNormal(normalize(varyingNormal.xyz));
}

void main(void) {
	albedoAndGlossMap = vec4(getDiffuseColor(), getGloss());
	normalMap = vec4(getNormal(), 0, 0);
}

//***************************************************************************
@effect 
//***************************************************************************

shader Deferred {
	
	flags basic_deferred;

	pass GBuffer {
		
		depth_stencil_state {
			depth_state true true lessEq;
			stencil_test false;
		}
		
		blend_state {
			blend false;
		}
		
		raster_state {
			raster solid back true;
			scissor false;
			anti_aliasing false false;
		}
		
		program {
			
			param vec4:diffuseAndGloss DiffuseColorAndGloss;
			param texture:diffuseMap DiffuseMap;
			option USE_DIFFUSE_SAMPLER HasDiffuseMap;
			
			vertex_program VSGBuffer;
			fragment_program PSGBuffer;
		}
	}
}
