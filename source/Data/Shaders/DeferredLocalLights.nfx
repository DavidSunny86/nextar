//***************************************************************************
@effect 
//***************************************************************************
shader DeferredLocalLights {
	
	flags BasicDeferred;

	pass Illumination {
	
		depth_stencil_state {
			depth_state false;
			stencil_test false;
		}
		
		blend_state {
			blend false;
		}
		
		raster_state {
			raster solid back true;
			scissor false;
			anti_aliasing false false;
		}
	
		program {
			vertex_program VSOmni
			pixel_program PSOmni
		}
	}
}

//***************************************************************************
@GLSL:VSOmni
//***************************************************************************
#version 330

in vec2 vertPos;
smooth out vec2 texCoord;

void main(void)
{
	gl_Position = vec4(vertPos.x, vertPos.y, 0, 1);
	texCoord = vertPos * vec2(0.5, 0.5) + vec2(0.5, 0.5);
}

//***************************************************************************
@GLSL:PSOmni
//***************************************************************************
#version 330

sampler2D depthMap;
sampler2D normalMap;
sampler2D albedoAndGlossMap;

uniform per_view_transform {
	mat4 matInvProj;
};

uniform per_object_props {
	vec3 lightColor;
	vec4 lightPosAndRadius;
};

smooth in vec2 texCoord;
out vec4 vFragColor;

vec3 getDecodedNormal(vec4 enc) {
    vec4 nn = enc*vec4(2,2,0,0) + vec4(-1,-1,1,-1);
    float l = dot(nn.xyz,-nn.xyw);
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2 + vec3(0,0,-1);
}

vec3 getPosition(vec2 texCoord) {
    float z = texture(depthMap, texCoord).r;  
    float x = texCoord.x * 2 - 1;
    float y = (1 - texCoord.y) * 2 - 1;
    vec4 vProjectedPos = vec4(x, y, z, 1.0f);
    vec4 vPositionVS = mul(vProjectedPos, matInvProj);  
    // Divide by w to get the view-space position
    return vPositionVS.xyz / vPositionVS.w;  
}

vec3 getNormal(vec2 texCoord) {
	return getDecodedNormal(texture(normalMap, texCoord));
}

void main(void) {
	vec3 n = getNormal(texCoord);
	vec3 p = getPosition(texCoord);
	vec3 lightDir =  (p - lightPosAndRadius.xyz);
	float distanceToLight = dot(lightDir, lightDir);
	lightDir = normalize(lightDir);
	vec4 albedoAndGloss = texture(albedoAndGlossMap, texCoord);
	// Dot product gives us diffuse intensity
	float diff = max(0.0, dot(n, lightDir));
	// Multiply intensity by diffuse color, force alpha to 1.0
	vFragColor.rgb = diff * albedoAndGloss.rgb * lightColor;
	// Specular Light
	vec3 vReflection = reflect(-lightDir,	n);
	float spec = max(0.0, dot(n, vReflection));
	// If the diffuse light is zero, donâ€™t even bother with the pow function
	if(diff != 0) {
		float fSpec = pow(spec, albedoAndGloss.a);
		vFragColor.rgb += vec3(fSpec, fSpec, fSpec);
	}
	float atten = clamp(1 - distanceToLight/(lightPosAndRadius.w*lightPosAndRadius.w), 0.0, 1.0);
	vFragColor.rgb *= (atten*atten);
	vFragColor.a = 1;
}
